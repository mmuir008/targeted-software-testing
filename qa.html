<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Services - Targeted Software Testing Corporation</title>
  <link rel="stylesheet" href="css/styles.css">
</head>
<body>
<header>
  <table>
    <tr>
      <td><img src="images/logo1.jpeg" alt="Targeted Testing Logo" style="height:80px;"></td>
      <td>&nbsp;</td>
      <td><h1>Software QA Services We Offer</h1></td>
    </tr>
  </table>
  <br/>
  <nav>
    <a href="index.html">Home</a>
    <a href="about.html">About</a>
    <a href="startup.html">Startup?</a>
    <a href="services.html">Services</a>
    <a href="future.html">Future</a>
    <a href="contact.html">Contact</a>
    <a href="downloads.html">Downloads</a>
  </nav>
</header>
<main>
  <h2>QA Testing Services</h2>
  <p><b>1. Derive User Scenarios from Requirements</b></p>
  <p>Understand the system's expected behavior by translating written requirements into realistic user workflows.</p>
  <ul>
    <li>Read functional specifications or user stories.</li>
    <li>Identify typical and atypical user paths.</li>
    <li>Include edge cases, exceptions, and error states.</li>
    <li>Collaborate with stakeholders for clarification where needed.</li>
  </ul>
  <p><b>2. Write Test Cases Based on These Scenarios</b></p>
  <p>Create structured test definitions that describe how to validate each identified user scenario.</p>
  <ul>
    <li>Define test inputs, steps, and expected results.</li>
    <li>Write both positive (happy path) and negative (error path) tests.</li>
    <li>Assign each test to a related requirement or user story.</li>
    <li>Use consistent naming and structure for easy review and maintenance.</li>
  </ul>
  <p><b>3. Write Test Frameworks to Support These Test Cases</b></p>
  <p>Build the reusable infrastructure required to run automated test cases efficiently and consistently.</p>
  <ul>
    <li>Set up a test project structure using your chosen language(s) and toolset.</li>
    <li>Implement reusable components like page objects, API clients, or utilities.</li>
    <li>Configure reporting (e.g., Allure, Extent), logging, and assertions.</li>
    <li>Enable easy parameterization and environment switching.</li>
  </ul>
  <p><b>4. Implement Automated Test Classes Using These Frameworks</b></p>
  <p>Develop automated scripts that execute your test cases on demand or continuously.</p>
  <ul>
    <li>Use tools like Selenium, Appium, REST Assured, or Playwright as requested.</li>
    <li>Write test code to simulate user actions or send/validate API requests.</li>
    <li>Include robust error handling and wait mechanisms.</li>
    <li>Validate results using assert statements and custom verifications.</li>
  </ul>
  <p><b>5. Create Test Suites Based on Collections of Related Test Classes</b></p>
  <p>Organize your tests into logical groupings to streamline execution and reporting.</p>
  <ul>
    <li>Create smoke, regression, feature-specific, or integration test suites.</li>
    <li>Tag or annotate tests for selective runs (e.g., @Smoke, @Critical)</li>
    <li>Define execution order if needed (e.g., dependent tests).</li>
    <li>Group by product area (e.g., Login, Payments, Reports).</li>
  </ul>
  <p><b>6. Set Up CI/CD Integration to Run Test Suites Automatically</b></p>
  <p>Ensure your tests run continuously as part of your development and deployment pipelines.</p>
  <ul>
    <li>Connect your framework to CI tools like Jenkins, GitHub Actions, or GitLab.</li>
    <li>Trigger tests on every code push, merge, or release.</li>
    <li>Publish test results with pass/fail indicators and logs.</li>
    <li>Set up alerts or gates to block faulty deployments.</li>
  </ul>
  <p><b>7. Find the Minimal Set of Test Cases to Quickly Verify New Releases</b></p>
  <p>Select and execute only the most relevant tests to validate a specific change or release.</p>
  <ul>
    <li>Analyze code diffs or change logs to identify affected areas.</li>
    <li>Choose test cases related to changed components or workflows.</li>
    <li>Include critical smoke tests for baseline coverage.</li>
    <li>Use tagging or metadata to filter and prioritize relevant tests.</li>
  </ul>
  <p><b>8. Understand the Code and Offer Tests for New Functionality</b></p>
  <p>Stay involved with code evolution so you can proactively cover new features with tests.</p>
  <ul>
    <li>Review pull requests, commits, or architecture diagrams.</li>
    <li>Ask developers about design intentions and tricky areas.</li>
    <li>Write test cases and automation scripts to target untested functionality.</li>
    <li>Update or refactor old tests to stay aligned with code changes.</li>
  </ul>
  <br/>
  <p>Anything else you'd like us to test?  <a href="contact.html">GET IN TOUCH</a></p>
</main>
<footer>
  <p>&copy; 2025 Targeted Software Testing</p>
</footer>
</body>
</html>